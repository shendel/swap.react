import BigInteger from 'bigi'

import { BigNumber } from 'bignumber.js'
import * as bitcoin from 'bitcoinjs-lib'
import * as bip32 from 'bip32'
import * as bip39 from 'bip39'

import bitcoinMessage from 'bitcoinjs-message'
import { getState } from 'redux/core'
import reducers from 'redux/core/reducers'
import { ltc, apiLooper, constants, api } from 'helpers'

const getRandomMnemonicWords = () => bip39.generateMnemonic()
const validateMnemonicWords = (mnemonic) => bip39.validateMnemonic(mnemonic)

const sweepToMnemonic = (mnemonic, path) => {
  const wallet = getWalletByWords(mnemonic, path)
  localStorage.setItem(constants.privateKeyNames.ktcMnemonic, wallet.WIF)
  return wallet.WIF
}

const isSweeped = () => {
  const {
    user: {
      ltcData,
      ltcMnemonicData,
    },
  } = getState()

  if (ltcMnemonicData
    && ltcMnemonicData.address
    && ltcData
    && ltcData.address
    && ltcData.address.toLowerCase() !== ltcMnemonicData.address.toLowerCase()
  ) return false

  return true
}

const getSweepAddress = () => {
  const {
    user: {
      ltcMnemonicData,
    },
  } = getState()

  if (ltcMnemonicData && ltcMnemonicData.address) return ltcMnemonicData.address
  return false
}

const auth = (privateKey) => {
  
}

const getWalletByWords = (mnemonic, walletNumber = 0, path) => {
  const seed = bip39.mnemonicToSeedSync(mnemonic);
  const root = bip32.fromSeed(seed, ltc.network);
  const node = root.derivePath((path) ? path : `m/44'/0'/0'/0/${walletNumber}`)

  const account = bitcoin.payments.p2pkh({
    pubkey: node.publicKey,
    network: ltc.network,
  })

  return {
    mnemonic,
    address: account.address,
    publicKey: node.publicKey.toString('Hex'),
    WIF: node.toWIF(),
    node,
    account,
  }
}

window.LTC_getWalletByWords = getWalletByWords

const getPrivateKeyByAddress = (address) => {
  const {
    user: {
      ltcData: {
        address: oldAddress,
        privateKey,
      },
      ltcMnemonicData: {
        address: mnemonicAddress,
        privateKey: mnemonicKey,
      }
    },
  } = getState()

  if (oldAddress.toLowerCase() === address.toLowerCase()) return privateKey
  if (mnemonicAddress.toLowerCase() === address.toLowerCase()) return mnemonicKey
}


const login = (privateKey) => {
  let keyPair

  if (privateKey) {
    const hash  = bitcoin.crypto.sha256(privateKey)
    const d     = BigInteger.fromBuffer(hash)
    
    keyPair     = bitcoin.ECPair.fromWIF(privateKey, ltc.network)
  }
  else {
    console.info('Created account Litecoin ...')
    keyPair     = bitcoin.ECPair.makeRandom({ network: ltc.network })
    privateKey  = keyPair.toWIF()
  }

  localStorage.setItem(constants.privateKeyNames.ltc, privateKey)

  const account       = bitcoin.ECPair.fromWIF(privateKey, ltc.network) // eslint-disable-line
  const { publicKey } = account
  const { address }   = bitcoin.payments.p2pkh({
    pubkey: account.publicKey,
    network: ltc.network,
  })

  const data = {
    account,
    keyPair,
    address,
    privateKey,
    publicKey,
  }

  window.getLtcAddress = () => data.address

  console.info('Logged in with Litecoin', data)
  reducers.user.setAuthData({ name: 'ltcData', data })
}

const getBalance = () => {
  const { user: { ltcData: { address } } } = getState()

  return apiLooper.get('ltc', `/addr/${address}`)
    .then(({ balance, unconfirmedBalance }) => {
      console.log('LTC Balance: ', balance)
      console.log('LTC unconfirmedBalance Balance: ', unconfirmedBalance)
      reducers.user.setBalance({ name: 'ltcData', amount: balance, unconfirmedBalance })
      return balance
    })
    .catch((e) => {
      reducers.user.setBalanceError({ name: 'ltcData' })
    })
}

const fetchBalance = (address) =>
  apiLooper.get('ltc', `/addr/${address}`)
    .then(({ balance }) => balance)

const fetchTx = (hash) =>
  apiLooper.get('ltc', `/tx/${hash}`)
    .then(({ fees, ...rest }) => ({
      fees: BigNumber(fees).multipliedBy(1e8),
      ...rest,
    }))

const fetchTxInfo = (hash) =>
  fetchTx(hash)
    .then(({ vin, ...rest }) => ({
      senderAddress: vin ? vin[0].addr : null,
      ...rest,
    }))

const getTransaction = (address) =>
  new Promise((resolve) => {
    const { user: { ltcData: { address: userAddress } } } = getState()
    address = address || userAddress
   
    const url = `/txs/?address=${address}`
    function getValue(item) {
      if (item.vin.filter(item => item.addr === address).length
          === item.vin.length
          && item.vout.filter(item => item.scriptPubKey.addresses[0] === address).length
          === item.vout.length) {
        return (parseFloat(item.valueIn) - parseFloat(item.valueOut)).toFixed(8)  // eslint-disable-next-line
      } else {
        return item.vin.filter(item => item.addr === address).length > 0
          ? item.vout.filter(item => item.scriptPubKey.addresses[0] !== address)
            .reduce((sum, current) =>  sum + parseFloat(current.value), 0)
          : item.vout.filter(item => item.scriptPubKey.addresses[0] === address)
            .reduce((sum, current) =>  sum + parseFloat(current.value), 0)
      }
    }

    return apiLooper.get('ltc', url)
      .then((res) => {
        const transactions = res.txs.map((item) => {
          const direction = item.vin[0].addr !== address ? 'in' : 'out'
          const isSelf = direction === 'out'
            && item.vout.filter((item) =>
              item.scriptPubKey.addresses[0] === address
            ).length === item.vout.length

          return ({
            type: 'ltc',
            hash: item.txid,
            canEdit: address === userAddress,
            confirmations: item.confirmations,
            value: isSelf
              ? item.fees
              : item.vout.filter((item) => {
                const currentAddress = item.scriptPubKey.addresses[0]

                return direction === 'in'
                  ? (currentAddress === address)
                  : (currentAddress !== address)
              })[0].value,
            date: item.time * 1000,
            direction: isSelf ? 'self' : direction,
          })
        })
        resolve(transactions)
      })
      .catch(() => {
        resolve([])
      })
  })

const getTx = (txRaw) => {

  return txRaw.transactionHash
}

const getLinkToInfo = (tx) => {

  if(!tx) {
    return
  }

  return `https://etherscan.io/tx/${tx}`
}

const send = async ({ from, to, amount, feeValue, speed } = {}) => {
  const { user: { ltcData: { privateKey } } } = getState()
  const keyPair = bitcoin.ECPair.fromWIF(privateKey, ltc.network)

  feeValue = feeValue || await ltc.estimateFeeValue({ inSatoshis: true, speed })

  const tx            = new bitcoin.TransactionBuilder(ltc.network)
  const unspents      = await fetchUnspents(from)

  const fundValue     = new BigNumber(String(amount)).multipliedBy(1e8).integerValue().toNumber()
  const totalUnspent  = unspents.reduce((summ, { satoshis }) => summ + satoshis, 0)
  const skipValue     = totalUnspent - fundValue - feeValue

  unspents.forEach(({ txid, vout }) => tx.addInput(txid, vout, 0xfffffffe))
  tx.addOutput(to, fundValue)

  if (skipValue > 546) {
    tx.addOutput(from, skipValue)
  }

  tx.inputs.forEach((input, index) => {
    tx.sign(index, keyPair)
  })

  const txRaw = tx.buildIncomplete()

  await broadcastTx(txRaw.toHex())

  return txRaw
}

const fetchUnspents = (address) =>
  apiLooper.get('ltc', `/addr/${address}/utxo`)

const broadcastTx = (txRaw) =>
  apiLooper.post('ltc', `/tx/send`, {
    body: {
      rawtx: txRaw,
    },
  })

const signMessage = (message, encodedPrivateKey) => {
  const keyPair = bitcoin.ECPair.fromWIF(encodedPrivateKey, [bitcoin.networks.bitcoin, bitcoin.networks.testnet])
  const privateKey = keyPair.d.toBuffer(32)

  const signature = bitcoinMessage.sign(message, privateKey, keyPair.compressed)

  return signature.toString('base64')
}

const getReputation = () => Promise.resolve(0)

export default {
  login,
  getBalance,
  getTransaction,
  send,
  fetchUnspents,
  broadcastTx,
  fetchTx,
  getTx,
  getLinkToInfo,
  fetchTxInfo,
  fetchBalance,
  signMessage,
  getReputation,
  getWalletByWords,
  getRandomMnemonicWords,
  validateMnemonicWords,
  sweepToMnemonic,
  isSweeped,
  getSweepAddress,
  //getDataByAddress,
}
